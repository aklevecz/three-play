(self.webpackChunkthreescape=self.webpackChunkthreescape||[]).push([[826],{424:(n,e,r)=>{"use strict";r.d(e,{Z:()=>g});var t=r(645),o=r.n(t),i=r(667),s=r.n(i),c=r(288),a=o()((function(n){return n[1]})),l=s()(c);a.push([n.id,"@font-face {\r\n  font-family: Euclid;\r\n  src: url("+l+') format("woff");\r\n}\r\n\r\ndiv {\r\n  font-family: Euclid;\r\n}\r\n',""]);const g=a},826:(n,e,r)=>{"use strict";var t=r(379),o=r.n(t),i=r(424);o()(i.Z,{insert:"head",singleton:!1}),i.Z.locals;var s=r(212),c=r(219),a=r(875),l=r(886);let g=200;const v={particlesData:[],positions:null,colors:null,particles:new s.u9r,pointCloud:null,particlePositions:null,linesMesh:null,group:new s.ZAu,uuids:[],uniforms:{},sizes:[]};const d={showDots:!0,showLines:!0,minDistance:150,limitConnections:!1,maxConnections:20,particleCount:500,resolution:!1};var p,x,u;const f={container:null,stats:(0,c.Z)(),gui:new a.XS,scene:new s.xsS,camera:null,controls:null,group:new s.ZAu,renderer:new s.CP7({antialias:!0}),animation:null};!function(){const n=document.createElement("div");n.id="root",document.body.appendChild(n)}(),function(n=!1,e=800,r=!1){f.container=document.getElementById("root");const t=window.innerWidth/window.innerHeight;if(f.camera=new s.cPb(45,t,1,4e3),f.camera.position.z=750,f.controls=new l.z(f.camera,f.container),f.controls.autoRotate=!1,f.controls.autoRotateSpeed=8,f.controls.maxDistance=3e3,f.scene.add(f.group),r?f.renderer.setPixelRatio(.7):f.renderer.setPixelRatio(window.devicePixelRatio),f.renderer.setSize(window.innerWidth,window.innerHeight),f.renderer.outputEncoding=s.knz,f.container.appendChild(f.renderer.domElement),f.container.appendChild(f.stats.dom),window.addEventListener("resize",(function(){f.camera.aspect=window.innerWidth/window.innerHeight,f.camera.updateProjectionMatrix(),f.renderer.setSize(window.innerWidth,window.innerHeight)}),!1),n){const n=new s.nvb(e,e,e),r=new s.vBJ;r.blending=s.WMw,r.color.setHex(16711680),r.transparent=!0;const t=new s.fQA(new s.Kj0(n,r));f.group.add(t)}}(!1,800,"development"===production),function(){const n=(new s.dpR).load(r(891));n.wrapS=s.rpg,n.wrapT=s.rpg,x=new s.Aip(150,150,150),new s.vBJ({color:16777215,transparent:!0}),u=new s.jyz({uniforms:{time:{value:0},sphereTexture:{value:n}},vertexShader:r(673),fragmentShader:r(387)}),p=new s.Kj0(x,u),f.scene.add(p)}(),function(){v.positions=new Float32Array(3e6),v.colors=new Float32Array(3e6);const n=(new s.dpR).load(r(891));v.uniforms={pointTexture:{value:n},u_color:{value:new s.Pa4(1,0,0)}},n.flipY=!1,new s.jyz({uniforms:v.uniforms,vertexShader:r(403),fragmentShader:r(368),depthTest:!1,transparent:!0,alphaTest:0,opacity:0,vertexColors:!0}),new s.UY4({vertexColors:!0,color:16777215,size:30,blending:s.WMw,transparent:!0,sizeAttenuation:!1});const e=new s.jyz({fragmentShader:r(348),vertexShader:r(170),vertexColors:!0,blending:s.WMw});v.particlePositions=new Float32Array(3e3),v.sizes=[];for(let n=0;n<1e3;n++){const e=800*Math.random()-400,r=800*Math.random()-400,t=800*Math.random()-400;v.particlePositions[3*n]=e,v.particlePositions[3*n+1]=r,v.particlePositions[3*n+2]=t,v.colors[3*n]=Math.random(),v.colors[3*n+1]=Math.random(),v.colors[3*n+2]=Math.random(),v.particlesData.push({velocity:new s.Pa4(2*Math.random()-1,2*Math.random()-1,2*Math.random()-1),numConnections:0}),v.sizes.push(10)}v.particles.setDrawRange(0,g),v.particles.setAttribute("position",new s.TlE(v.particlePositions,3).setUsage(s.dj0)),v.particles.setAttribute("color",new s.TlE(v.colors,3).setUsage(s.dj0)),v.particles.setAttribute("size",new s.a$l(v.sizes,1).setUsage(s.dj0)),v.pointCloud=new s.woe(v.particles,e),v.group.add(v.pointCloud),v.uuids.push(v.pointCloud.uuid)}(),function(){const n=new s.u9r;n.setAttribute("position",new s.TlE(v.positions,3).setUsage(s.dj0)),n.setAttribute("color",new s.TlE(v.colors,3).setUsage(s.dj0)),n.computeBoundingSphere(),n.setDrawRange(0,0);const e=new s.nls({vertexColors:!0,blending:s.WMw,transparent:!0});v.linesMesh=new s.ejS(n,e),v.group.add(v.linesMesh),v.uuids.push(v.linesMesh.uuid),f.group.add(v.group)}(),f.animation=function(){let n=0,e=0,r=0;const t=v.pointCloud.geometry;for(let n=0;n<g;n++)v.particlesData[n].numConnections=0;for(let o=0;o<g;o++){const i=v.particlesData[o];if(v.particlePositions[3*o]+=i.velocity.x,v.particlePositions[3*o+1]+=i.velocity.y,v.particlePositions[3*o+2]+=i.velocity.z,(v.particlePositions[3*o+1]<-400||v.particlePositions[3*o+1]>400)&&(i.velocity.y=-i.velocity.y),(v.particlePositions[3*o]<-400||v.particlePositions[3*o]>400)&&(i.velocity.x=-i.velocity.x),(v.particlePositions[3*o+2]<-400||v.particlePositions[3*o+2]>400)&&(i.velocity.z=-i.velocity.z),d.limitConnections&&i.numConnections>=d.maxConnections)continue;const{x:s,y:c,z:a}=f.camera.position,l=v.particlePositions[3*o]-s,p=v.particlePositions[3*o+1]-c,x=v.particlePositions[3*o+2]-a;Math.sqrt(l*l+p*p+x*x)<100&&(t.attributes.size.array[o]=500);for(let t=o+1;t<g;t++){const s=v.particlesData[t];if(d.limitConnections&&s.numConnections>=d.maxConnections)continue;const c=v.particlePositions[3*o]-v.particlePositions[3*t],a=v.particlePositions[3*o+1]-v.particlePositions[3*t+1],l=v.particlePositions[3*o+2]-v.particlePositions[3*t+2],g=Math.sqrt(c*c+a*a+l*l);if(g<d.minDistance){i.numConnections++,s.numConnections++;const c=1-g/d.minDistance;v.positions[n++]=v.particlePositions[3*o],v.positions[n++]=v.particlePositions[3*o+1],v.positions[n++]=v.particlePositions[3*o+2],v.positions[n++]=v.particlePositions[3*t],v.positions[n++]=v.particlePositions[3*t+1],v.positions[n++]=v.particlePositions[3*t+2],v.colors[e++]=c,v.colors[e++]=c,v.colors[e++]=c,v.colors[e++]=c,v.colors[e++]=c,v.colors[e++]=c,r++}}}const o=v.linesMesh.geometry;o.setDrawRange(0,2*r),o.attributes.position.needsUpdate=!0,o.attributes.color.needsUpdate=!0,t.attributes.position.needsUpdate=!0,t.attributes.size.needsUpdate=!0},function n(){f.animation(),Date.now(),u.uniforms.time.value+=.007,requestAnimationFrame(n),f.stats.update(),Date.now(),f.controls.update(),f.renderer.render(f.scene,f.camera)}(),function(){const{gui:n}=f;n.add(d,"showDots").onChange((function(n){v.pointCloud.visible=n})),n.add(d,"showLines").onChange((function(n){v.linesMesh.visible=n})),n.add(d,"minDistance",10,300),n.add(d,"maxConnections",0,30,1),n.add(d,"limitConnections"),n.add(d,"particleCount",0,1e3,1).onChange((function(n){g=parseInt(n),v.particles.setDrawRange(0,g)})),n.add(d,"resolution").onChange((function(n){f.renderer.setPixelRatio(n?window.devicePixelRatio:.7)}))}()},348:n=>{n.exports="float circle(in vec2 _st, in float _radius) {\r\n    vec2 dist = _st - vec2(0.5);\r\n    return 1.-smoothstep(_radius - (_radius*0.01),\r\n                            _radius + (_radius*0.01),\r\n                            dot(dist,dist)*4.0);\r\n}\r\n\r\nvoid main() {\r\n    vec2 st = gl_PointCoord;\r\n    vec3 color = vec3(circle(st,0.9));\r\n    if (color.r > .0) {\r\n    gl_FragColor = vec4(color, 1.0);\r\n    } else {\r\n        discard;\r\n    }\r\n    // if (pct < .3) {\r\n    //     gl_FragColor = vec4(color,1.0);\r\n    // } else {\r\n    //    discard;\r\n    // }\r\n}\r\n"},170:n=>{n.exports="attribute float size;\r\nvoid main() {\r\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\r\n\r\n    gl_PointSize = size * ( 2500.0 / -mvPosition.z );\r\n\r\n    gl_Position = projectionMatrix * mvPosition;\r\n\r\n}"},368:n=>{n.exports="\t\t\tuniform sampler2D pointTexture;\r\n            uniform vec3 u_color;\r\n\t\t\tvarying vec3 vColor;\r\n            varying vec2 vUv;\r\n\t\t\tvoid main() {\r\n                vec4 texture = texture2D(pointTexture ,  gl_PointCoord);\r\n\t\t\t\tgl_FragColor = vec4(vColor,1.0) * vec4(1.0 - texture.r, 1.0 - texture.g, 1.0 - texture.b, 1.0);\r\n                gl_FragColor = texture;\r\n\t\t\t}\r\n"},387:n=>{n.exports="uniform sampler2D sphereTexture; \r\nvarying vec2 vUv;\r\nvarying float noise;\r\nvarying vec3 vNormal;\r\nvoid main() {\r\n\tvec2 uv = normalize( vNormal ).xy * 0.5 + 0.5;\r\n\t// vec4 texto = texture( sphereTexture, uv*40. );\r\n    float noiseColor = 1. - .2 * noise;\r\n    vec3 color = vec3(noiseColor);\r\n    // gl_FragColor = vec4( color.rgb, 1.0 ) * texture;\r\n    gl_FragColor = vec4(color, 1.0);\r\n}"},673:n=>{n.exports="// Include the Ashima code here!\r\nvarying vec3 vNormal;\r\nvarying vec2 vUv;\r\nvarying float noise;\r\nuniform float time;\r\n  \r\n  vec3 mod289(vec3 x)\r\n{\r\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\n\r\nvec4 mod289(vec4 x)\r\n{\r\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\n\r\nvec4 permute(vec4 x)\r\n{\r\n  return mod289(((x*34.0)+1.0)*x);\r\n}\r\n\r\nvec4 taylorInvSqrt(vec4 r)\r\n{\r\n  return 1.79284291400159 - 0.85373472095314 * r;\r\n}\r\n\r\nvec3 fade(vec3 t) {\r\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\r\n}\r\n\r\n// Classic Perlin noise\r\nfloat cnoise(vec3 P)\r\n{\r\n  vec3 Pi0 = floor(P); // Integer part for indexing\r\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\r\n  Pi0 = mod289(Pi0);\r\n  Pi1 = mod289(Pi1);\r\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\r\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\r\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\r\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\r\n  vec4 iz0 = Pi0.zzzz;\r\n  vec4 iz1 = Pi1.zzzz;\r\n\r\n  vec4 ixy = permute(permute(ix) + iy);\r\n  vec4 ixy0 = permute(ixy + iz0);\r\n  vec4 ixy1 = permute(ixy + iz1);\r\n\r\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\r\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\r\n  gx0 = fract(gx0);\r\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\r\n  vec4 sz0 = step(gz0, vec4(0.0));\r\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\r\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\r\n\r\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\r\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\r\n  gx1 = fract(gx1);\r\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\r\n  vec4 sz1 = step(gz1, vec4(0.0));\r\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\r\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\r\n\r\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\r\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\r\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\r\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\r\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\r\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\r\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\r\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\r\n\r\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\r\n  g000 *= norm0.x;\r\n  g010 *= norm0.y;\r\n  g100 *= norm0.z;\r\n  g110 *= norm0.w;\r\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\r\n  g001 *= norm1.x;\r\n  g011 *= norm1.y;\r\n  g101 *= norm1.z;\r\n  g111 *= norm1.w;\r\n\r\n  float n000 = dot(g000, Pf0);\r\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\r\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\r\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\r\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\r\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\r\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\r\n  float n111 = dot(g111, Pf1);\r\n\r\n  vec3 fade_xyz = fade(Pf0);\r\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\r\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\r\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \r\n  return 2.2 * n_xyz;\r\n}\r\n\r\n// Classic Perlin noise, periodic variant\r\nfloat pnoise(vec3 P, vec3 rep)\r\n{\r\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\r\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\r\n  Pi0 = mod289(Pi0);\r\n  Pi1 = mod289(Pi1);\r\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\r\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\r\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\r\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\r\n  vec4 iz0 = Pi0.zzzz;\r\n  vec4 iz1 = Pi1.zzzz;\r\n\r\n  vec4 ixy = permute(permute(ix) + iy);\r\n  vec4 ixy0 = permute(ixy + iz0);\r\n  vec4 ixy1 = permute(ixy + iz1);\r\n\r\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\r\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\r\n  gx0 = fract(gx0);\r\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\r\n  vec4 sz0 = step(gz0, vec4(0.0));\r\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\r\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\r\n\r\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\r\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\r\n  gx1 = fract(gx1);\r\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\r\n  vec4 sz1 = step(gz1, vec4(0.0));\r\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\r\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\r\n\r\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\r\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\r\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\r\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\r\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\r\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\r\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\r\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\r\n\r\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\r\n  g000 *= norm0.x;\r\n  g010 *= norm0.y;\r\n  g100 *= norm0.z;\r\n  g110 *= norm0.w;\r\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\r\n  g001 *= norm1.x;\r\n  g011 *= norm1.y;\r\n  g101 *= norm1.z;\r\n  g111 *= norm1.w;\r\n\r\n  float n000 = dot(g000, Pf0);\r\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\r\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\r\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\r\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\r\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\r\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\r\n  float n111 = dot(g111, Pf1);\r\n\r\n  vec3 fade_xyz = fade(Pf0);\r\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\r\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\r\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \r\n  return 2.2 * n_xyz;\r\n}\r\n\r\nfloat turbulence( vec3 p ) {\r\n    float w = 100.0;\r\n    float t = -.5;\r\n    for (float f = 1.0 ; f <= 10.0 ; f++ ){\r\n        float power = pow( 2.0, f );\r\n        t += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );\r\n    }\r\n    return t;\r\n}\r\n\r\nvoid main() {\r\n\r\n    vUv = uv;\r\n    vNormal = normal;\r\n    // add time to the noise parameters so it's animated\r\n    noise = 10.0 *  -.10 * turbulence( .5 * normal + time );\r\n    float b = 10.0 * pnoise( 0.05 * position + vec3( 2.0 * time ), vec3( 100.0 ) );\r\n    float displacement = - noise + b;\r\n    \r\n    vec3 newPosition = position + normal * displacement;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );\r\n\r\n}"},403:n=>{n.exports="attribute float size;\r\nvarying vec3 vColor;\r\nvarying vec2 vUv;\r\nvoid main() {\r\n    vUv = uv;\r\n    vColor = color;\r\n\r\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\r\n\r\n    gl_PointSize = size * ( 300.0 / -mvPosition.z );\r\n\r\n    gl_Position = projectionMatrix * mvPosition;\r\n\r\n}"},288:(n,e,r)=>{"use strict";n.exports=r.p+"727a249c9815fda17bf8.woff"},891:(n,e,r)=>{"use strict";n.exports=r.p+"3c29d552d5cdd9229435.png"}},0,[[826,666,216]]]);